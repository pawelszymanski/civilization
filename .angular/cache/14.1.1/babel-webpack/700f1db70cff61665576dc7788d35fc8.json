{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"../stores/camera.store\";\nimport * as i2 from \"../stores/size.store\";\nimport * as i3 from \"../stores/map.store\";\nexport let TileUiService = /*#__PURE__*/(() => {\n  class TileUiService {\n    constructor(cameraStore, sizeStore, mapStore) {\n      this.cameraStore = cameraStore;\n      this.sizeStore = sizeStore;\n      this.mapStore = mapStore;\n      this.subscribeToData();\n    }\n\n    subscribeToData() {\n      this.cameraStore.camera.subscribe(camera => this.camera = camera);\n      this.sizeStore.size.subscribe(size => this.size = size);\n      this.mapStore.map.subscribe(map => this.map = map);\n    } // Checks if tile needs to be drawn, counts in tiles partially visible too\n\n\n    isTileOfScreenCoordsOnScreen(coordsOnCanvasPx) {\n      return coordsOnCanvasPx.x + this.size.tile.width >= 0 && coordsOnCanvasPx.x <= this.size.screen.width && coordsOnCanvasPx.y + this.size.tile.height >= 0 && coordsOnCanvasPx.y <= this.size.screen.height;\n    } // Coords on the screen in pixels\n\n\n    coordsOnScreenPx(tile) {\n      const indentation = tile.grid.y % 2 === 1 ? this.size.tile.halfWidth : 0; // Indentation for tiles in odd rows\n\n      const firstColumnFix = tile.grid.x === this.map.width - 1 ? -this.size.row.width : 0; // This fills empty space caused by indentation filled by tiles from last column\n\n      return {\n        x: tile.grid.x * this.size.tile.width + this.camera.translate.x + indentation + firstColumnFix,\n        y: tile.grid.y * this.size.row.height + this.camera.translate.y\n      };\n    } // Coords on map plus translation\n\n\n    tileCoordsOnScreenPx(tile) {\n      let coordsOnScreenPx = null; // Try if (x, y) coords are in the viewport...\n\n      const primaryScreenCoordsCandidate = this.coordsOnScreenPx(tile);\n\n      if (this.isTileOfScreenCoordsOnScreen(primaryScreenCoordsCandidate)) {\n        coordsOnScreenPx = primaryScreenCoordsCandidate;\n      } // ...if not on map then also try (x - mapWidth, y)\n\n\n      if (!coordsOnScreenPx) {\n        const alternativeScreenCoordsCandidate = Object.assign({}, primaryScreenCoordsCandidate);\n        alternativeScreenCoordsCandidate.x = alternativeScreenCoordsCandidate.x + this.size.row.width;\n\n        if (this.isTileOfScreenCoordsOnScreen(alternativeScreenCoordsCandidate)) {\n          coordsOnScreenPx = alternativeScreenCoordsCandidate;\n        }\n      } // Then if any was in viewport set it\n\n\n      return coordsOnScreenPx;\n    }\n\n    verifyGridCoordsOutOfBounds(gridCoords) {\n      return gridCoords.y >= 0 && gridCoords.y < this.map.height ? gridCoords : null;\n    }\n\n    normalizeGridX(x) {\n      return (x + this.map.width) % this.map.width;\n    }\n\n    areGridCoordsValid(gridCoords) {\n      const isYok = gridCoords.x >= 0 && gridCoords.x < this.map.width;\n      const isXok = gridCoords.y >= 0 && gridCoords.y < this.map.height;\n      return isXok && isYok;\n    } // Visualization: https://stackoverflow.com/questions/7705228/hexagonal-grids-how-do-you-find-which-hexagon-a-point-is-in\n\n\n    mapCoordsPxToGridCoords(mapCoords) {\n      // Candidate Y coordinate\n      const y = Math.floor(mapCoords.y / this.size.row.height);\n\n      if (y < 0 || y > this.map.height) {\n        return null;\n      } // clicked above or bellow the map, no need to continue\n      // Candidate X coordinate\n\n\n      let x = Math.floor(mapCoords.x / this.size.tile.width);\n      const isOddRow = y % 2 === 1;\n      const clickedTileToLeft = mapCoords.x % this.size.tile.width < this.size.tile.halfWidth; // Clicked a left side of the tile, since the row is indented means it's the tile to the left that was clicked\n\n      if (isOddRow && clickedTileToLeft) {\n        x -= 1;\n      }\n\n      if (x < 0) {\n        x += this.map.width;\n      }\n\n      if (x === this.map.width) {\n        x -= this.map.width;\n      } // Check if in the wide rectangle in the center of the hex\n\n\n      const grid = {\n        x,\n        y\n      };\n      const tileCoords = {\n        x: (mapCoords.x + this.size.tile.width + (isOddRow ? +this.size.tile.halfWidth : 0)) % this.size.tile.width,\n        y: (mapCoords.y + this.size.row.height) % this.size.row.height // make sure its row height, otherwise obob\n\n      }; // Check if in the wide rectangle in the center of the hex\n\n      const isAboveOneQuarter = tileCoords.y >= this.size.tile.oneQuarterHeight;\n      const isBellowThreeQuarters = tileCoords.y <= this.size.tile.threeQuarterHeight;\n\n      if (isAboveOneQuarter && isBellowThreeQuarters) {\n        return this.areGridCoordsValid(grid) ? grid : null;\n      } // Check upper left and right triangles\n\n\n      if (!isAboveOneQuarter) {\n        const slope = this.size.tile.oneQuarterHeight / this.size.tile.halfWidth; // y = ax + b, this is a\n\n        if (tileCoords.x <= this.size.tile.halfWidth) {\n          // left side of the tile\n          const isOutside = this.size.tile.oneQuarterHeight - tileCoords.x * slope > tileCoords.y;\n          const candidate = isOutside ? {\n            x: isOddRow ? grid.x : grid.x - 1,\n            y: grid.y - 1\n          } : grid;\n          candidate.x = this.normalizeGridX(candidate.x);\n          return this.areGridCoordsValid(candidate) ? candidate : null;\n        } else {\n          const isOutside = (tileCoords.x - this.size.tile.halfWidth) * slope > tileCoords.y;\n          const candidate = isOutside ? {\n            x: isOddRow ? grid.x + 1 : grid.x,\n            y: grid.y - 1\n          } : grid;\n          candidate.x = this.normalizeGridX(candidate.x);\n          return this.areGridCoordsValid(candidate) ? candidate : null;\n        }\n      } // Lower left and right triangles are also upper ones for tiles bellow so do not need to be checked\n\n\n      return null;\n    }\n\n    eventToMapCoordsPx(event) {\n      let x = event.clientX - this.camera.translate.x;\n\n      if (x >= this.size.row.width) {\n        x -= this.size.row.width;\n      }\n\n      const y = event.clientY - this.camera.translate.y;\n      return {\n        x,\n        y\n      };\n    } // Returns Tile for a given mouse event. MIGHT BE NULL since this.mapCoordsPxToGridCoords might be null\n\n\n    mouseEventToTile(event) {\n      const mapCoordsPx = this.eventToMapCoordsPx(event);\n      const grid = this.mapCoordsPxToGridCoords(mapCoordsPx);\n      return grid ? this.map.tiles[grid.x * this.map.height + grid.y] : null;\n    } // Returns all tiles in the distance equal or lower to radius from the center tile (a bigger hexagon)\n    // Normalized for position  existence\n\n\n    tilesInRadius(centerTile, radius = 0) {\n      if (radius === 0) {\n        return [centerTile];\n      }\n\n      const candidates = [];\n      const isCenterOddRow = centerTile.grid.y % 2 === 1;\n\n      for (let y = -radius; y <= radius; y++) {\n        const yDelta = Math.abs(y);\n        const fromX = -radius + (isCenterOddRow ? Math.ceil(yDelta / 2) : Math.floor(yDelta / 2));\n        const toX = fromX + 2 * radius - yDelta;\n\n        for (let x = fromX; x <= toX; x++) {\n          candidates.push({\n            x: centerTile.grid.x + x,\n            y: centerTile.grid.y + y\n          });\n        }\n      }\n\n      return candidates.filter(grid => grid.y >= 0 && grid.y < this.map.height).map(grid => this.map.tiles[(grid.x + this.map.width) % this.map.width * this.map.height + grid.y]);\n    }\n\n  }\n\n  TileUiService.ɵfac = function TileUiService_Factory(t) {\n    return new (t || TileUiService)(i0.ɵɵinject(i1.CameraStore), i0.ɵɵinject(i2.SizeStore), i0.ɵɵinject(i3.MapStore));\n  };\n\n  TileUiService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: TileUiService,\n    factory: TileUiService.ɵfac,\n    providedIn: 'root'\n  });\n  return TileUiService;\n})();","map":null,"metadata":{},"sourceType":"module"}