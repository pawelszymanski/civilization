{"ast":null,"code":"import { VIEWPORT_LINE_STYLE, VIEWPORT_LINE_WIDTH, MINIMAP_WIDTH, MINIMAP_HEIGHT } from '../../../consts/minimap.const';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../../stores/camera.store\";\nimport * as i2 from \"../../../stores/size.store\";\nimport * as i3 from \"../../../stores/map.store\";\nconst _c0 = [\"minimap\"];\nconst _c1 = [\"viewport\"];\nconst _c2 = [\"class\", \"mini-map-component\"]; // General flow: Subscribe to map. When map changes send it over to worker to generate new minimap image.\n// On worker message use minimap image and add the viewport rectangle locally.\n\nexport let MiniMapComponent = /*#__PURE__*/(() => {\n  class MiniMapComponent {\n    constructor(cameraStore, sizeStore, mapStore) {\n      this.cameraStore = cameraStore;\n      this.sizeStore = sizeStore;\n      this.mapStore = mapStore;\n      this.MINIMAP_WIDTH = MINIMAP_WIDTH;\n      this.MINIMAP_HEIGHT = MINIMAP_HEIGHT;\n      this.isDragging = false;\n      this.isMinimapAvailable = false;\n      this.subscriptions = []; // Without this minimap renders not 0, but +4px to the bottom, no clue why\n\n      this.hostTop = 'calc(100% - ' + MINIMAP_HEIGHT + 'px)';\n    }\n\n    ngOnInit() {\n      this.initMinimapCanvasWorker();\n      this.initMinimapCtx();\n      this.initViewportCtx();\n      this.subscribeToData();\n      this.requestAnimationFrame();\n    }\n\n    ngOnDestroy() {\n      this.cancelAnimationFrame();\n      this.unsubscribeFromData();\n      this.destroyWorker();\n    }\n\n    initMinimapCanvasWorker() {\n      // Needs to be a type: module, https://stackoverflow.com/questions/48045569/whats-the-difference-between-a-classic-and-module-web-worker\n      this.minimapCanvasWorker = new Worker(new URL('./../../../workers/minimap-canvas.worker', import.meta.url), {\n        type: 'module'\n      });\n\n      this.minimapCanvasWorker.onmessage = message => {\n        this.minimapImageData = message.data;\n        this.isMinimapAvailable = true;\n      };\n    }\n\n    initMinimapCtx() {\n      this.minimapCtx = this.minimapCanvas.nativeElement.getContext('2d');\n    }\n\n    initViewportCtx() {\n      this.viewportCtx = this.viewportCanvas.nativeElement.getContext('2d');\n      this.viewportCtx.strokeStyle = VIEWPORT_LINE_STYLE;\n      this.viewportCtx.lineWidth = VIEWPORT_LINE_WIDTH;\n    }\n\n    subscribeToData() {\n      this.subscriptions.push(this.cameraStore.camera.subscribe(camera => this.onCameraUpdate(camera)), this.sizeStore.size.subscribe(size => this.onSizeUpdate(size)), this.mapStore.map.subscribe(map => this.onMapUpdate(map)));\n    }\n\n    onCameraUpdate(camera) {\n      this.camera = camera;\n\n      if (this.size && this.camera) {\n        this.drawViewport();\n      }\n    }\n\n    onSizeUpdate(size) {\n      this.size = size;\n\n      if (this.size && this.camera) {\n        this.drawViewport();\n      }\n    }\n\n    onMapUpdate(map) {\n      this.map = map;\n      this.minimapCanvasWorker.postMessage(map);\n    }\n\n    requestAnimationFrame() {\n      this.animationFrameId = window.requestAnimationFrame(() => {\n        this.requestAnimationFrame();\n\n        if (this.minimapImageData) {\n          this.minimapCtx.putImageData(this.minimapImageData, 0, 0);\n          this.minimapImageData = null;\n        }\n      });\n    }\n\n    cancelAnimationFrame() {\n      window.cancelAnimationFrame(this.animationFrameId);\n    }\n\n    unsubscribeFromData() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n    destroyWorker() {\n      this.minimapCanvasWorker.terminate();\n    } // EVENTS\n\n\n    onMousedown(event) {\n      const mapCoords = this.eventToMapCoords(event);\n      this.cameraStore.setTranslate(mapCoords);\n      this.isDragging = true;\n    }\n\n    onMousemove(event) {\n      if (this.isDragging) {\n        const mapCoords = this.eventToMapCoords(event);\n        this.cameraStore.setTranslate(mapCoords);\n      }\n    }\n\n    onMouseup() {\n      this.isDragging = false;\n    } // OTHER\n\n\n    eventToMapCoords(event) {\n      return {\n        x: Math.floor(-event.offsetX * (this.size.row.width / this.viewportCtx.canvas.width)) + this.size.screen.halfWidth,\n        y: Math.floor(-event.offsetY * (this.size.map.height / this.viewportCtx.canvas.height)) + this.size.screen.halfHeight\n      };\n    }\n\n    drawViewport() {\n      const topRatio = -this.camera.translate.y / this.size.map.height;\n      const bottomRatio = (-this.camera.translate.y + this.size.screen.height) / this.size.map.height;\n      const leftRatio = -this.camera.translate.x / this.size.map.width;\n      const rightRatio = (-this.camera.translate.x + this.size.screen.width) % this.size.map.width / this.size.map.width;\n      const top = this.viewportCtx.canvas.height * topRatio;\n      const bottom = this.viewportCtx.canvas.height * bottomRatio;\n      const left = this.viewportCtx.canvas.width * leftRatio;\n      const right = this.viewportCtx.canvas.width * rightRatio;\n      this.viewportCtx.clearRect(0, 0, MINIMAP_WIDTH, MINIMAP_HEIGHT);\n      this.drawLine(left, top, left, bottom);\n      this.drawLine(right, top, right, bottom);\n\n      if (right > left) {\n        this.drawLine(left, top, right, top);\n        this.drawLine(left, bottom, right, bottom);\n      } else {\n        this.drawLine(right, top, 0, top);\n        this.drawLine(right, bottom, 0, bottom);\n        this.drawLine(left, top, this.viewportCtx.canvas.width, top);\n        this.drawLine(left, bottom, this.viewportCtx.canvas.width, bottom);\n      }\n    }\n\n    drawLine(x1, y1, x2, y2) {\n      this.viewportCtx.beginPath();\n      this.viewportCtx.moveTo(x1, y1);\n      this.viewportCtx.lineTo(x2, y2);\n      this.viewportCtx.stroke();\n    }\n\n  }\n\n  MiniMapComponent.ɵfac = function MiniMapComponent_Factory(t) {\n    return new (t || MiniMapComponent)(i0.ɵɵdirectiveInject(i1.CameraStore), i0.ɵɵdirectiveInject(i2.SizeStore), i0.ɵɵdirectiveInject(i3.MapStore));\n  };\n\n  MiniMapComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: MiniMapComponent,\n    selectors: [[\"\", 8, \"mini-map-component\"]],\n    viewQuery: function MiniMapComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n        i0.ɵɵviewQuery(_c1, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.minimapCanvas = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.viewportCanvas = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function MiniMapComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"top\", ctx.hostTop);\n      }\n    },\n    attrs: _c2,\n    decls: 4,\n    vars: 4,\n    consts: [[3, \"width\", \"height\"], [\"minimap\", \"\"], [3, \"width\", \"height\", \"mousedown\", \"mousemove\", \"mouseup\"], [\"viewport\", \"\"]],\n    template: function MiniMapComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"canvas\", 0, 1);\n        i0.ɵɵelementStart(2, \"canvas\", 2, 3);\n        i0.ɵɵlistener(\"mousedown\", function MiniMapComponent_Template_canvas_mousedown_2_listener($event) {\n          return ctx.onMousedown($event);\n        })(\"mousemove\", function MiniMapComponent_Template_canvas_mousemove_2_listener($event) {\n          return ctx.onMousemove($event);\n        })(\"mouseup\", function MiniMapComponent_Template_canvas_mouseup_2_listener() {\n          return ctx.onMouseup();\n        });\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"width\", ctx.isMinimapAvailable ? ctx.MINIMAP_WIDTH : 0)(\"height\", ctx.isMinimapAvailable ? ctx.MINIMAP_HEIGHT : 0);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"width\", ctx.isMinimapAvailable ? ctx.MINIMAP_WIDTH : 0)(\"height\", ctx.isMinimapAvailable ? ctx.MINIMAP_HEIGHT : 0);\n      }\n    },\n    styles: [\".mini-map-component{position:absolute;top:auto;right:auto;bottom:0;left:0;z-index:200;box-shadow:2px -2px 2px #0003}.mini-map-component canvas{position:absolute}\\n\"],\n    encapsulation: 2\n  });\n  return MiniMapComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}