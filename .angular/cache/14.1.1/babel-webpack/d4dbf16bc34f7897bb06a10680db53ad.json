{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar minimap_const_1 = require(\"../consts/minimap.const\"); // tslint:disable-next-line:new-parens no-unused-expression\n\n\nnew (\n/** @class */\nfunction () {\n  function MinimapCanvasWorker() {\n    // True: render perfect rectangle. False: Render map with top and bottom hexes fully displayed.\n    this.CUT_TOP_AND_BOTTOM_HEXES = true;\n    this.initCanvas();\n    this.addEventListener();\n  }\n\n  MinimapCanvasWorker.prototype.initCanvas = function () {\n    // @ts-ignore\n    this.canvas = new OffscreenCanvas(minimap_const_1.MINIMAP_WIDTH, minimap_const_1.MINIMAP_HEIGHT);\n    this.ctx = this.canvas.getContext('2d');\n  };\n\n  MinimapCanvasWorker.prototype.addEventListener = function () {\n    var _this = this;\n\n    addEventListener('message', function (message) {\n      return _this.onMessage(message);\n    });\n  };\n\n  MinimapCanvasWorker.prototype.onMessage = function (message) {\n    var map = message.data;\n    this.paintBackground();\n    this.paintTiles(map);\n    var imageData = this.ctx.getImageData(0, 0, this.ctx.canvas.width, this.ctx.canvas.height); // @ts-ignore\n\n    postMessage(imageData);\n  };\n\n  MinimapCanvasWorker.prototype.isOddRow = function (tile) {\n    return tile.grid.y % 2 === 1;\n  };\n\n  MinimapCanvasWorker.prototype.calcTileSize = function (map) {\n    var tileWidth = this.ctx.canvas.width / map.width; // * 3: rows overlap, so every tile takes 3/4 of it is height on the map\n    // -1: is to not count very top and very bottom triangles (to keep output a rectangle). To include them use +1.\n\n    var heightFourths = map.height * 3 + (this.CUT_TOP_AND_BOTTOM_HEXES ? -1 : 1);\n    var oneFourth = this.ctx.canvas.height / heightFourths;\n    var tileHeight = oneFourth * 4;\n    return {\n      x: tileWidth,\n      y: tileHeight\n    };\n  };\n\n  MinimapCanvasWorker.prototype.calcTileCoords = function (tile, tileSize) {\n    // Y need to address overlapping of the rows and cutting top and bottom triangles out\n    var oddRowFix = this.isOddRow(tile) ? tileSize.x / 2 : 0;\n    var topAndBottomHexesFix = this.CUT_TOP_AND_BOTTOM_HEXES ? -tileSize.y * 0.25 : 0;\n    return {\n      x: tile.grid.x * tileSize.x + oddRowFix,\n      y: tile.grid.y * tileSize.y * 0.75 + topAndBottomHexesFix\n    };\n  };\n\n  MinimapCanvasWorker.prototype.paintBackground = function () {\n    this.ctx.fillStyle = minimap_const_1.MINIMAP_BACKGROUND_STYLE;\n    this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n  };\n\n  MinimapCanvasWorker.prototype.paintTiles = function (map) {\n    var tileSize = this.calcTileSize(map);\n\n    for (var _i = 0, _a = map.tiles; _i < _a.length; _i++) {\n      var tile = _a[_i];\n      var coordsPx = this.calcTileCoords(tile, tileSize);\n      var color = minimap_const_1.TERRAIN_BASE_TO_COLOR_MAP[tile.terrain.base.id];\n      this.paintTile(coordsPx, tileSize, color); // Paint odd row tiles in the last column also on the left edge of the map\n\n      if (tile.grid.x === map.width - 1 && this.isOddRow(tile)) {\n        coordsPx.x -= map.width * tileSize.x;\n        this.paintTile(coordsPx, tileSize, color);\n      }\n    }\n  };\n\n  MinimapCanvasWorker.prototype.paintTile = function (coordsPx, tileSize, color) {\n    this.ctx.beginPath();\n    this.ctx.moveTo(coordsPx.x + tileSize.x * 0.50, coordsPx.y);\n    this.ctx.lineTo(coordsPx.x + tileSize.x, coordsPx.y + tileSize.y * 0.25);\n    this.ctx.lineTo(coordsPx.x + tileSize.x, coordsPx.y + tileSize.y * 0.75);\n    this.ctx.lineTo(coordsPx.x + tileSize.x * 0.50, coordsPx.y + tileSize.y);\n    this.ctx.lineTo(coordsPx.x, coordsPx.y + tileSize.y * 0.75);\n    this.ctx.lineTo(coordsPx.x, coordsPx.y + tileSize.y * 0.25);\n    this.ctx.closePath();\n    this.ctx.fillStyle = color;\n    this.ctx.fill();\n  };\n\n  return MinimapCanvasWorker;\n}())();","map":null,"metadata":{},"sourceType":"script"}